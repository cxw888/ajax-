<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="jquery.js"></script>
    <style>
        .wrapper {
            width: 70%;
            margin: 70px auto;
        }

        .slider {
            width: 100%;
            height: 30px;
            background-color: aliceblue;
            position: relative;
        }

        .progress-bar {
            background-color: aquamarine;
            height: 30px;
            width: 0px;
            position: absolute;
            top: 0;
            left: 0;
        }

        .drager {
            /* 当指定 cursor: move; 时，鼠标光标通常会变为一个四向箭头（通常是带有四个小箭头的十字箭头），这通常表示该元素可以被移动或拖动。 */
            cursor: move;
            width: 45px;
            height: 60px;
            position: absolute;
            top: -15px;
            left: 0;
            background: url('./pic/6.jpeg');
            /* 当设置为 cover 时，背景图像将被等比缩放，以便其宽度和高度中的较小者恰好适应内容区域，同时保持图像的宽高比。
            这意味着背景图像会完全覆盖元素的背景区域，但可能会被部分裁剪以确保填充整个元素，且不会出现空白。 */
            background-size: cover;
        }
    </style>
</head>

<body>
    <!-- 真实应用中 slider 不可能顶着页面左边布局，他可能是中间或是页面任何地方，所以计算位置时不能按0算开始，方便理解，这里我套一层 wrapper，并居中对齐 -->
    <div class="wrapper">
        <div class="slider">
            <div class="progress-bar"></div>
            <!-- drager 对象标记 draggable=false属性，避免触发原生拖动那个阴影出来，效果跟你 preverDefault 一样，也可以用 css 的user-select: none;实现，效果一样 -->
            <div class="drager" draggable="false">
            </div>
        </div>
</body>
<script>
    $(function () {
        const $slider = $('.slider');
        const $drager = $slider.find('.drager');
        const $progressBar = $slider.find('.progress-bar')
        const boxWidth = $slider.width();
        // 不带单位

        // 变量次之，空一行，美观
        let isDraged = false;
        let startX = null;

        $drager
            // 函数结构赋值
            .mousedown(({ pageX }) => {
                isDraged = true;
                startX = pageX;
            });

        $(document)
            .mousemove(({ pageX }) => {
                // if (!isDraged) return; 这行代码的意思是：“如果 isDraged 不是 true（即 isDraged 为 false）
                // ，则立即结束当前函数的执行，不执行后续代码。”
                if (!isDraged) return;
                // 第一种写法 const dragerLastX = parseInt($drager.css("left") || 0); .css("left")带单位
                const dragerLastX = $drager.position().left || 0;
                // position().left是$drager距离父元素左边的偏移量 不带单位
                // ：这是一个逻辑或（||）操作符的使用。如果$drager[0].style.left存在且不是假值
                // （例如，不是空字符串、0、null、undefined、NaN、false等），那么它会返回这个值。否则，它会返回0。
                const mouseOffsetX = pageX - startX;
                let dragerTargetX = dragerLastX + mouseOffsetX;

                // 最大值限制
                if (dragerTargetX > boxWidth) {
                    dragerTargetX = boxWidth;
                }

                // 最小值限制
                if (dragerTargetX < 0) {
                    dragerTargetX = 0;
                }

                $drager.css("left", `${dragerTargetX}px`)
                // 模版字符串  `里面写修改内容`${里面写变量} `${dragerTargetX}px`

                // 计算进度条的位置
                const leftToPercentage = (dragerTargetX / boxWidth) * 100;
                $progressBar.css({
                    width: `${leftToPercentage}%`
                });
                // 本轮位置计算完之后，将开始位置计为本位置，方便下次响应时move 事件时位置起点正确
                startX = pageX;
            })
            .mouseup(() => {
                isDraged = false;
            });
    })

</script>

</html>